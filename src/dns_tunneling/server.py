# https://www.infoblox.com/dns-security-resource-center/dns-security-faq/is-dns-tcp-or-udp-port-53/#:~:text=DNS%20has%20always%20been%20designed,in%20a%20single%20UDP%20packet. 
# https://unix.stackexchange.com/questions/731630/what-is-the-purpose-of-the-127-0-1-1-entry-in-etc-hosts 
# https://hacks.mozilla.org/2018/05/a-cartoon-intro-to-dns-over-https/
# https://www.youtube.com/watch?v=mpQZVYPuDGU 
# https://www.youtube.com/watch?v=S6uYZ8V1vRc 
# https://www.youtube.com/watch?v=HnUDtycXSNE
# https://www.youtube.com/watch?v=oVZfLERBioY
# https://howdns.works/

from scapy.layers.dns import DNS, DNSRR
import base64
import socket
import math
import sys
import os

domains = {
    "base": b"proiectretele2024reg.software.",
    "init": b"init.proiectretele2024reg.software.",
    "stop": b"end.proiectretele2024reg.software."
}

MAX_CHUNK_SIZE = 255 # max size of DNS TXT records 

class DNSTunnel:
    def __init__(self, path: str):
        self.text = base64.b64encode(open(path, "r").read().encode())
        self.offset = math.ceil(len(self.text) / MAX_CHUNK_SIZE) + 5
        self.tunnel_connections = {}
        self.r_tunnel_connections = {}
        
        os.system("systemctl disable systemd-resolved")
        os.system("systemctl stop systemd-resolved")
        
    def parse_dns_request(self, request):
        packet = DNS(request)
        dns = packet.getlayer(DNS)
        
        if dns is not None and dns.opcode == 0 and domains["base"] in dns.qd.qname:
            message = ""
            
            if dns.qd.qname == domains["init"]:
                seq = 0 if not self.tunnel_connections else ((max(self.tunnel_connections) + self.offset) % ((1 << 32) - 1))
                self.tunnel_connections[seq] = seq
                self.r_tunnel_connections[seq] = seq
                message = base64.b64encode(str(seq).encode())
            else:
                id = int(dns.an.rdata[0])
                if id not in self.tunnel_connections:
                    self.r_tunnel_connections[id] = self.r_tunnel_connections[id-1]
                    
                index = id - self.r_tunnel_connections[id]
                message = self.text[index * MAX_CHUNK_SIZE: (index + 1) * MAX_CHUNK_SIZE]
            
            if len(message) == 0:
                dns_answer = DNSRR(rrname=dns.qd.qname, ttl=330,rclass="IN", type="CNAME", rdata=domains["stop"])
            else:
                dns_answer = DNSRR(rrname=dns.qd.qname, ttl=330, rclass="IN", type="TXT", rdata=message)
            
            print(f"Sent {len(message)} bytes") 
            return DNS(id=packet[DNS].id, qr=1, aa=0,rcode=0, qd=packet.qd, an=dns_answer)
        
        forwarder = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        forwarder.sendto(request, ('8.8.8.8', 53))
        response, _ = forwarder.recvfrom(65535)
        forwarder.close()
        return response
    
    def run(self):
        dns_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, proto=socket.IPPROTO_UDP)
        dns_socket.bind(('0.0.0.0', 53))
        
        while True:
            try:
                request, source_address = dns_socket.recvfrom(65535)
                response = self.parse_dns_request(request)
                
                if response:
                    dns_socket.sendto(bytes(response), source_address)
            except KeyboardInterrupt:
                dns_socket.close()
                
                os.system("systemctl enable systemd-resolved")
                os.system("systemctl start systemd-resolved")
                
if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python script.py <file_path>")
        sys.exit(1)
        
    tunnel = DNSTunnel(sys.argv[1])
    tunnel.run()